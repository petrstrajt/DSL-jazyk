<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Referenční příručka symbolického jazyka nad Common Lisp</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        h1, h2, h3 {
            color: #333;
        }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.2em; }
        code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        ul {
            margin: 10px 0;
        }
        li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>Referenční příručka symbolického jazyka nad Common Lisp</h1>
    <p>Tato příručka poskytuje přehled nástrojů symbolického jazyka navrženého jako nadstavba nad Common Lisp. Jazyk používá přirozenou češtinu, eliminuje závorky a je určen pro snadné popisování programovacích úloh. Příručka slouží jako učební pomůcka pro rychlé seznámení s jazykem.</p>

    <h2>1. Základní informace</h2>
    <ul>
        <li><strong>Formát</strong>: Čistě textový, bloky odděleny prázdnými řádky.</li>
        <li><strong>Syntaxe</strong>: Striktní, s pevně danými klíčovými slovy pro jednoznačný převod do Common Lispu.</li>
        <li><strong>Cíl</strong>: Umožnit programátorům soustředit se na problém, ne na syntaxi.</li>
    </ul>

    <h2>2. Seznam nástrojů</h2>

    <h3>2.1. Definice funkce</h3>
    <p><strong>Syntaxe</strong>: <code>Vytvoř funkci pojmenovanou [název], která přijímá hodnotu [parametry].</code></p>
    <p><strong>Popis</strong>: Vytvoří funkci s parametry oddělenými slovem „a“.</p>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou přičti, která přijímá hodnotu x a hodnotu y.
Proveď součet x a y.
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>: <code>(defun přičti (x y) (+ x y))</code></p>

    <h3>2.2. Aritmetické operace</h3>
    <p><strong>Syntaxe</strong>: <code>Proveď [operace] [argumenty].</code></p>
    <p><strong>Operace</strong>:</p>
    <ul>
        <li><code>součet [x] a [y]</code> → <code>(+ x y)</code></li>
        <li><code>rozdíl [x] a [y]</code> → <code>(- x y)</code></li>
        <li><code>součin [x] a [y]</code> → <code>(* x y)</code></li>
        <li><code>podíl [x] a [y]</code> → <code>(/ x y)</code></li>
    </ul>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou čtverec, která přijímá hodnotu x.
Proveď součin x a x.
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>: <code>(defun čtverec (x) (* x x))</code></p>

    <h3>2.3. Podmínky</h3>
    <p><strong>Syntaxe</strong>:</p>
    <pre>
Pokud [podmínka], vrať [výsledek].
Jinak vrať [výsledek].
    </pre>
    <p><strong>Srovnávací operátory</strong>:</p>
    <ul>
        <li><code>je větší než</code> → <code>></code></li>
        <li><code>je menší než</code> → <code><</code></li>
        <li><code>je rovno</code> → <code>=</code></li>
        <li><code>je prázdný</code> → <code>null</code></li>
    </ul>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou větší, která přijímá hodnotu a a hodnotu b.
Pokud je a větší než b, vrať a.
Jinak vrať b.
    </pre>
    <p><strong>Převod do Lispu</strong>: <code>(defun větší (a b) (if (> a b) a b))</code></p>

    <h3>2.4. Proměnné</h3>
    <p><strong>Syntaxe</strong>:</p>
    <ul>
        <li><code>Definuj proměnnou [název] jako [hodnota].</code> → Vytvoří proměnnou.</li>
        <li><code>Ulož výsledek do proměnné [název].</code> → Aktualizuje proměnnou.</li>
    </ul>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou přičti_kvadrát, která přijímá hodnotu x.
Definuj proměnnou čtverec jako součin x a x.
Proveď součet čtverec a x.
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>: <code>(defun přičti_kvadrát (x) (let ((čtverec (* x x))) (+ čtverec x)))</code></p>

    <h3>2.5. Smyčky</h3>
    <p><strong>Syntaxe</strong>:</p>
    <pre>
Opakuj, dokud [podmínka].
[akce]
Konec opakování.
    </pre>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou součet_do, která přijímá hodnotu n.
Definuj proměnnou výsledek jako 0.
Definuj proměnnou i jako 1.
Opakuj, dokud je i menší nebo rovno n.
Proveď součet výsledek a i.
Ulož výsledek do proměnné výsledek.
Proveď součet i a 1.
Ulož výsledek do proměnné i.
Konec opakování.
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defun součet_do (n)
  (let ((výsledek 0) (i 1))
    (loop while (<= i n)
          do (setf výsledek (+ výsledek i))
             (setf i (+ i 1))
          finally (return výsledek))))
    </pre>

    <h3>2.6. Seznamy</h3>
    <h4>Vytvoření seznamu</h4>
    <p><strong>Syntaxe</strong>: <code>Vytvoř seznam obsahující [prvky].</code></p>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou vytvoř_dvojici, která přijímá hodnotu x a hodnotu y.
Vytvoř seznam obsahující x a y.
Vrať seznam.
    </pre>
    <p><strong>Převod do Lispu</strong>: <code>(defun vytvoř_dvojici (x y) (list x y))</code></p>

    <h4>Iterace přes seznam</h4>
    <p><strong>Syntaxe</strong>:</p>
    <pre>
Pro každou hodnotu [prvek] v seznamu [název_seznamu].
[akce]
Konec opakování.
    </pre>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou součet_seznamu, která přijímá hodnotu seznam.
Definuj proměnnou výsledek jako 0.
Pro každou hodnotu prvek v seznamu seznam.
Proveď součet výsledek a prvek.
Ulož výsledek do proměnné výsledek.
Konec opakování.
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defun součet_seznamu (seznam)
  (let ((výsledek 0))
    (dolist (prvek seznam)
      (setf výsledek (+ výsledek prvek)))
    výsledek))
    </pre>

    <h4>Manipulace se seznamem</h4>
    <p><strong>Syntaxe</strong>:</p>
    <ul>
        <li><code>Přidej prvek [hodnota] do seznamu [název_seznamu].</code> → <code>(cons hodnota název_seznamu)</code></li>
        <li><code>Vrať první prvek seznamu [název_seznamu].</code> → <code>(car název_seznamu)</code></li>
        <li><code>Vrať zbytek seznamu [název_seznamu].</code> → <code>(cdr název_seznamu)</code></li>
        <li><code>Spoj seznam [seznam1] a seznam [seznam2].</code> → <code>(append seznam1 seznam2)</code></li>
    </ul>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou přidej_na_začátek, která přijímá hodnotu x a hodnotu seznam.
Přidej prvek x do seznamu seznam.
Vrať seznam.
    </pre>
    <p><strong>Převod do Lispu</strong>: <code>(defun přidej_na_začátek (x seznam) (cons x seznam))</code></p>

    <h3>2.7. Makra</h3>
    <p><strong>Syntaxe</strong>:</p>
    <pre>
Vytvoř makro pojmenované [název], které přijímá hodnotu [parametry].
[tělo makra]
Vrať výsledek.
    </pre>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř makro pojmenované když, které přijímá hodnotu podmínka a hodnotu akce.
Vytvoř seznam obsahující symbol pokud a podmínka a akce a prázdný seznam.
Vrať seznam.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defmacro když (podmínka akce)
  (list 'if podmínka akce nil))
    </pre>

    <h3>2.8. Anonymní funkce (Lambda)</h3>
    <p><strong>Syntaxe</strong>:</p>
    <pre>
Vytvoř anonymní funkci, která přijímá hodnotu [parametry].
[tělo funkce]
Vrať výsledek.
    </pre>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou použij_lambda, která přijímá hodnotu x.
Definuj proměnnou f jako anonymní funkci, která přijímá hodnotu y.
Proveď součet y a 1.
Vrať výsledek.
Použij funkci f s hodnotou x.
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defun použij_lambda (x)
  (let ((f (lambda (y) (+ y 1))))
    (funcall f x)))
    </pre>

    <h3>2.9. Funkce vyššího řádu</h3>
    <p><strong>Syntaxe</strong>:</p>
    <ul>
        <li><code>Použij funkci [název_funkce] na seznam [seznam].</code> → <code>(mapcar název_funkce seznam)</code></li>
        <li><code>Filtruj seznam [seznam] podle funkce [název_funkce].</code> → <code>(remove-if-not název_funkce seznam)</code></li>
    </ul>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou zdvojnásob_vše, která přijímá hodnotu seznam.
Vytvoř anonymní funkci, která přijímá hodnotu x.
Proveď součin x a 2.
Vrať výsledek.
Použij tuto funkci na seznam seznam.
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defun zdvojnásob_vše (seznam)
  (mapcar (lambda (x) (* x 2)) seznam))
    </pre>

    <h3>2.10. Asociativní seznamy</h3>
    <p><strong>Syntaxe</strong>:</p>
    <ul>
        <li><code>Vytvoř asociativní seznam obsahující dvojice [klíč hodnota] a [klíč hodnota].</code></li>
        <li><code>Vrať hodnotu pro klíč [klíč] v asociativním seznamu [seznam].</code></li>
    </ul>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou najdi_hodnotu, která přijímá hodnotu klíč.
Vytvoř asociativní seznam obsahující dvojice "jmeno" "Jan" a dvojice "věk" 30.
Vrať hodnotu pro klíč klíč v tomto seznamu.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defun najdi_hodnotu (klíč)
  (assoc klíč '(("jmeno" . "Jan") ("věk" . 30))))
    </pre>

    <h3>2.11. Manipulace s řetězci</h3>
    <p><strong>Syntaxe</strong>:</p>
    <ul>
        <li><code>Spoj řetězce [řetězec1] a [řetězec2].</code> → <code>(concatenate 'string řetězec1 řetězec2)</code></li>
        <li><code>Vrať délku řetězce [řetězec].</code> → <code>(length řetězec)</code></li>
    </ul>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou pozdrav, která přijímá hodnotu jméno.
Spoj řetězce "Ahoj, " a jméno a "!".
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defun pozdrav (jméno)
  (concatenate 'string "Ahoj, " jméno "!"))
    </pre>

    <h3>2.12. Výstup na obrazovku</h3>
    <p><strong>Syntaxe</strong>: <code>Vytiskni [hodnota].</code> → <code>(print hodnota)</code></p>
    <p><strong>Příklad (Ahoj, světe!)</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou ahoj_svět, která nepřijímá žádné hodnoty.
Vytiskni "Ahoj, světe!".
Vrať výsledek.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defun ahoj_svět ()
  (print "Ahoj, světe!"))
    </pre>

    <h3>2.13. Čtení vstupu od uživatele</h3>
    <p><strong>Syntaxe</strong>: <code>Načti vstup do proměnné [název].</code> → <code>(setf název (read))</code></p>
    <p><strong>Popis</strong>: Načte vstup od uživatele (např. číslo, řetězec) a uloží ho do proměnné.</p>
    <p><strong>Příklad</strong>:</p>
    <pre>
Vytvoř funkci pojmenovanou načti_číslo, která nepřijímá žádné hodnoty.
Vytiskni "Zadej číslo:".
Načti vstup do proměnné číslo.
Vytiskni číslo.
Vrať číslo.
    </pre>
    <p><strong>Převod do Lispu</strong>:</p>
    <pre>
(defun načti_číslo ()
  (print "Zadej číslo:")
  (setf číslo (read))
  (print číslo)
  číslo)
    </pre>

    <h2>3. Jak používat příručku</h2>
    <ul>
        <li><strong>Učení</strong>: Procházej jednotlivé sekce a zkoušej příklady v našem jazyce.</li>
        <li><strong>Psaní kódu</strong>: Piš kód podle syntaxe a pošli ho ke kontrole. Přeložím ho do Lispu a vrátím výstup.</li>
        <li><strong>Vyhledávání</strong>: Použij <code>Ctrl+F</code> k nalezení konkrétních příkazů (např. „Vytvoř funkci“, „Vytiskni“).</li>
        <li><strong>Stažení</strong>: Ulož tento soubor jako <code>jazyk_referencni_prirucka.html</code> a otevři v prohlížeči.</li>
    </ul>

    <h2>4. Poznámky</h2>
    <ul>
        <li>Jazyk je verbose, aby byl srozumitelný pro začátečníky.</li>
        <li>Všechny konstrukce mapují na Common Lisp, takže kód lze spustit v prostředí jako SBCL nebo CLISP.</li>
        <li>Pro pokročilé funkce (např. makra) se doporučuje kombinovat s jednoduchými konstrukcemi pro lepší čitelnost.</li>
    </ul>
</body>
</html occurence=2>